<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Craft Agents ‚Äî Web</title>
<style>
  :root {
    --bg: #0d1117; --bg-secondary: #161b22; --bg-tertiary: #21262d;
    --border: #30363d; --text: #e6edf3; --text-secondary: #8b949e;
    --accent: #58a6ff; --accent-hover: #79c0ff;
    --error: #f85149; --success: #3fb950; --warning: #d29922;
    --user-bg: #1f3a5f; --assistant-bg: #161b22;
    --tool-bg: #1c2128; --tool-border: #30363d;
    --permission-bg: #2d1f0e; --permission-border: #d29922;
    --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    --mono: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    --radius: 8px;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: var(--font); background: var(--bg); color: var(--text); height: 100vh; overflow: hidden; }
  a { color: var(--accent); }
  button { font-family: var(--font); cursor: pointer; border: none; border-radius: var(--radius); }
  input, textarea { font-family: var(--font); background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text); border-radius: var(--radius); padding: 8px 12px; outline: none; }
  input:focus, textarea:focus { border-color: var(--accent); }

  /* Layout */
  #app { display: flex; height: 100vh; }
  #connect-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; gap: 16px; padding: 24px; }
  #connect-screen h1 { font-size: 24px; margin-bottom: 8px; }
  #connect-screen .form { display: flex; flex-direction: column; gap: 12px; width: 100%; max-width: 400px; }
  #connect-screen input { width: 100%; }
  #connect-screen .error { color: var(--error); font-size: 13px; }
  .btn-primary { background: var(--accent); color: #0d1117; padding: 10px 20px; font-weight: 600; font-size: 14px; }
  .btn-primary:hover { background: var(--accent-hover); }
  .btn-secondary { background: var(--bg-tertiary); color: var(--text); padding: 6px 14px; font-size: 13px; border: 1px solid var(--border); }
  .btn-secondary:hover { background: var(--border); }
  .btn-danger { background: transparent; color: var(--error); padding: 6px 14px; font-size: 13px; border: 1px solid var(--error); }
  .btn-danger:hover { background: rgba(248, 81, 73, 0.15); }
  .btn-success { background: var(--success); color: #0d1117; padding: 6px 14px; font-size: 13px; font-weight: 600; }
  .btn-success:hover { opacity: 0.9; }

  /* Sidebar */
  #sidebar { width: 280px; min-width: 280px; background: var(--bg-secondary); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
  #sidebar-header { padding: 12px 16px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border); }
  #sidebar-header h2 { font-size: 14px; font-weight: 600; }
  #session-list { flex: 1; overflow-y: auto; padding: 4px 0; }
  .session-item { padding: 10px 16px; cursor: pointer; border-bottom: 1px solid transparent; transition: background 0.1s; }
  .session-item:hover { background: var(--bg-tertiary); }
  .session-item.active { background: var(--bg-tertiary); border-left: 2px solid var(--accent); }
  .session-item .title { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .session-item .meta { display: flex; align-items: center; gap: 6px; margin-top: 3px; font-size: 11px; color: var(--text-secondary); }
  .session-item .badge { font-size: 10px; padding: 1px 6px; border-radius: 10px; font-weight: 600; }
  .badge-new { background: var(--accent); color: #0d1117; }
  .badge-processing { background: var(--warning); color: #0d1117; }

  /* Chat Area */
  #chat-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
  #chat-header { padding: 12px 20px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; min-height: 48px; }
  #chat-header .title { font-size: 14px; font-weight: 600; }
  #chat-header .status { font-size: 12px; color: var(--text-secondary); }
  #messages { flex: 1; overflow-y: auto; padding: 16px 20px; display: flex; flex-direction: column; gap: 12px; }
  #empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary); }

  /* Messages */
  .msg { padding: 10px 14px; border-radius: var(--radius); max-width: 100%; word-wrap: break-word; overflow-wrap: break-word; }
  .msg-user { background: var(--user-bg); align-self: flex-end; max-width: 80%; }
  .msg-assistant { background: var(--assistant-bg); border: 1px solid var(--border); }
  .msg-assistant pre { background: var(--bg-tertiary); padding: 10px; border-radius: 6px; overflow-x: auto; margin: 8px 0; font-family: var(--mono); font-size: 13px; }
  .msg-assistant code { font-family: var(--mono); font-size: 13px; background: var(--bg-tertiary); padding: 1px 4px; border-radius: 3px; }
  .msg-assistant pre code { background: none; padding: 0; }
  .msg-error { background: rgba(248, 81, 73, 0.1); border: 1px solid var(--error); color: var(--error); }
  .msg-status { background: transparent; color: var(--text-secondary); font-size: 12px; font-style: italic; text-align: center; padding: 4px; }
  .msg-plan { background: var(--bg-tertiary); border: 1px solid var(--accent); border-left: 3px solid var(--accent); }

  /* Tool calls */
  .tool-call { background: var(--tool-bg); border: 1px solid var(--tool-border); border-radius: var(--radius); margin: 6px 0; overflow: hidden; }
  .tool-header { padding: 8px 12px; font-size: 12px; font-weight: 600; display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; }
  .tool-header:hover { background: rgba(255,255,255,0.03); }
  .tool-header .arrow { transition: transform 0.15s; font-size: 10px; }
  .tool-header .arrow.open { transform: rotate(90deg); }
  .tool-header .tool-name { color: var(--accent); }
  .tool-header .tool-intent { color: var(--text-secondary); font-weight: 400; }
  .tool-body { padding: 0 12px 10px; display: none; }
  .tool-body.open { display: block; }
  .tool-body pre { font-family: var(--mono); font-size: 12px; background: var(--bg); padding: 8px; border-radius: 4px; overflow-x: auto; white-space: pre-wrap; max-height: 300px; overflow-y: auto; }
  .tool-result { margin-top: 6px; }
  .tool-result-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 3px; }
  .tool-spinner { display: inline-block; width: 10px; height: 10px; border: 2px solid var(--text-secondary); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Permission request */
  .permission-banner { background: var(--permission-bg); border: 1px solid var(--permission-border); border-radius: var(--radius); padding: 12px 16px; margin: 8px 0; }
  .permission-banner .perm-title { font-size: 13px; font-weight: 600; color: var(--warning); margin-bottom: 6px; }
  .permission-banner .perm-detail { font-family: var(--mono); font-size: 12px; background: var(--bg); padding: 8px; border-radius: 4px; margin-bottom: 10px; white-space: pre-wrap; max-height: 200px; overflow-y: auto; }
  .permission-banner .perm-actions { display: flex; gap: 8px; }

  /* Credential request */
  .credential-banner { background: var(--bg-tertiary); border: 1px solid var(--accent); border-radius: var(--radius); padding: 12px 16px; margin: 8px 0; }
  .credential-banner .cred-title { font-size: 13px; font-weight: 600; margin-bottom: 6px; }
  .credential-banner .cred-field { margin-bottom: 8px; }
  .credential-banner .cred-field label { font-size: 12px; color: var(--text-secondary); display: block; margin-bottom: 4px; }
  .credential-banner .cred-field input { width: 100%; }
  .credential-banner .cred-actions { display: flex; gap: 8px; }

  /* Input area */
  #input-area { padding: 12px 20px; border-top: 1px solid var(--border); display: flex; gap: 8px; align-items: flex-end; }
  #input-area textarea { flex: 1; resize: none; min-height: 40px; max-height: 200px; font-size: 14px; line-height: 1.5; }
  #send-btn { padding: 10px 20px; }
  #stop-btn { padding: 10px 16px; background: var(--error); color: white; font-weight: 600; font-size: 13px; display: none; }
  #stop-btn.visible { display: block; }

  /* Streaming cursor */
  .streaming-cursor { display: inline-block; width: 7px; height: 16px; background: var(--accent); animation: blink 1s step-end infinite; vertical-align: text-bottom; margin-left: 2px; }
  @keyframes blink { 50% { opacity: 0; } }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--text-secondary); }

  /* Responsive */
  @media (max-width: 768px) {
    #sidebar { width: 100%; min-width: auto; position: absolute; z-index: 10; height: 100vh; transform: translateX(-100%); transition: transform 0.2s; }
    #sidebar.open { transform: translateX(0); }
    .mobile-menu-btn { display: block !important; }
  }
  .mobile-menu-btn { display: none; background: none; color: var(--text); font-size: 20px; padding: 4px 8px; }

  /* Workspace selector */
  #workspace-select { font-size: 12px; background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text); border-radius: 4px; padding: 4px 8px; }
</style>
</head>
<body>
<div id="app">
  <!-- Connect Screen -->
  <div id="connect-screen">
    <h1>Craft Agents ‚Äî Web Access</h1>
    <p style="color: var(--text-secondary); font-size: 14px; text-align: center;">Connect to your running Craft Agents desktop app</p>
    <div class="form">
      <label style="font-size: 12px; color: var(--text-secondary);">Server URL</label>
      <input id="input-url" type="text" placeholder="http://localhost:19876">
      <label style="font-size: 12px; color: var(--text-secondary);">Auth Token</label>
      <input id="input-token" type="password" placeholder="Paste token from Electron app logs">
      <button class="btn-primary" onclick="doConnect()">Connect</button>
      <div id="connect-error" class="error"></div>
    </div>
  </div>

  <!-- Main App (hidden until connected) -->
  <div id="sidebar" style="display: none;">
    <div id="sidebar-header">
      <h2>Sessions</h2>
      <button class="btn-secondary" onclick="createNewSession()">+ New</button>
    </div>
    <div style="padding: 8px 12px; border-bottom: 1px solid var(--border);">
      <select id="workspace-select" style="width: 100%;" onchange="loadSessions()"></select>
    </div>
    <div id="session-list"></div>
  </div>
  <div id="chat-area" style="display: none;">
    <div id="chat-header">
      <div style="display: flex; align-items: center; gap: 8px;">
        <button class="mobile-menu-btn" onclick="toggleSidebar()">‚ò∞</button>
        <span class="title" id="chat-title">Select a session</span>
      </div>
      <span class="status" id="chat-status"></span>
    </div>
    <div id="messages">
      <div id="empty-state">
        <p>Select a session or create a new one</p>
      </div>
    </div>
    <div id="input-area">
      <textarea id="msg-input" placeholder="Type a message..." rows="1" onkeydown="handleInputKey(event)" oninput="autoGrow(this)"></textarea>
      <button id="stop-btn" onclick="cancelProcessing()">Stop</button>
      <button id="send-btn" class="btn-primary" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<script>
// ========== State ==========
let serverUrl = '';
let authToken = '';
let ws = null;
let sessions = [];
let workspaces = [];
let activeSessionId = null;
let activeSession = null; // full session with messages
let streamingText = '';
let streamingTurnId = null;
let toolCalls = new Map(); // toolUseId -> { name, input, result, intent, displayName }
let pendingPermissions = new Map(); // requestId -> permission data
let pendingCredentials = new Map(); // requestId -> credential data

// ========== API Helpers ==========
async function api(method, path, body) {
  const opts = {
    method,
    headers: { 'Authorization': `Bearer ${authToken}`, 'Content-Type': 'application/json' },
  };
  if (body !== undefined) opts.body = JSON.stringify(body);
  const res = await fetch(`${serverUrl}${path}`, opts);
  if (!res.ok) {
    const err = await res.json().catch(() => ({ error: res.statusText }));
    throw new Error(err.error || `HTTP ${res.status}`);
  }
  return res.json();
}

// ========== Connection ==========
async function doConnect() {
  const urlInput = document.getElementById('input-url');
  const tokenInput = document.getElementById('input-token');
  const errorEl = document.getElementById('connect-error');
  serverUrl = urlInput.value.replace(/\/$/, '') || `${location.protocol}//${location.host}`;
  authToken = tokenInput.value.trim();
  errorEl.textContent = '';

  if (!authToken) { errorEl.textContent = 'Token is required'; return; }
  try {
    sessions = await api('GET', '/api/sessions');
    workspaces = await api('GET', '/api/workspaces');
  } catch (e) {
    errorEl.textContent = `Connection failed: ${e.message}`;
    return;
  }
  // Save to localStorage
  localStorage.setItem('wb_url', serverUrl);
  localStorage.setItem('wb_token', authToken);
  showApp();
  connectWS();
}

function showApp() {
  document.getElementById('connect-screen').style.display = 'none';
  document.getElementById('sidebar').style.display = 'flex';
  document.getElementById('chat-area').style.display = 'flex';
  renderWorkspaces();
  renderSessions();
}

function connectWS() {
  if (ws) { ws.close(); ws = null; }
  const wsUrl = serverUrl.replace(/^http/, 'ws') + `/ws?token=${encodeURIComponent(authToken)}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = () => console.log('[ws] connected');
  ws.onmessage = (e) => { try { handleEvent(JSON.parse(e.data)); } catch (err) { console.error('[ws] parse error:', err); } };
  ws.onclose = () => { console.log('[ws] disconnected, reconnecting in 3s...'); setTimeout(connectWS, 3000); };
  ws.onerror = () => {};
}

// ========== Rendering ==========
function renderWorkspaces() {
  const sel = document.getElementById('workspace-select');
  sel.innerHTML = workspaces.map(w => `<option value="${w.id}">${esc(w.name)}</option>`).join('');
}

function renderSessions() {
  const list = document.getElementById('session-list');
  const wsId = document.getElementById('workspace-select').value;
  const filtered = sessions.filter(s => s.workspaceId === wsId).sort((a, b) => b.lastMessageAt - a.lastMessageAt);
  list.innerHTML = filtered.map(s => {
    const active = s.id === activeSessionId ? 'active' : '';
    const title = s.name || s.preview || 'New Session';
    const time = relTime(s.lastMessageAt);
    let badges = '';
    if (s.isProcessing) badges += '<span class="badge badge-processing">‚óè</span>';
    if (s.hasUnread) badges += '<span class="badge badge-new">NEW</span>';
    return `<div class="session-item ${active}" onclick="openSession('${s.id}')">
      <div class="title">${esc(title)}</div>
      <div class="meta">${badges}<span>${time}</span></div>
    </div>`;
  }).join('') || '<div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 13px;">No sessions</div>';
}

async function loadSessions() {
  try { sessions = await api('GET', '/api/sessions'); renderSessions(); } catch (e) { console.error('Failed to load sessions:', e); }
}

// ========== Session Management ==========
async function createNewSession() {
  const wsId = document.getElementById('workspace-select').value;
  if (!wsId) return;
  try {
    const session = await api('POST', '/api/sessions', { workspaceId: wsId });
    sessions.unshift(session);
    renderSessions();
    openSession(session.id);
  } catch (e) { console.error('Failed to create session:', e); }
}

async function openSession(id) {
  activeSessionId = id;
  streamingText = '';
  streamingTurnId = null;
  toolCalls.clear();
  pendingPermissions.clear();
  pendingCredentials.clear();
  renderSessions();
  document.getElementById('chat-title').textContent = 'Loading...';
  document.getElementById('chat-status').textContent = '';
  document.getElementById('messages').innerHTML = '';

  try {
    activeSession = await api('GET', `/api/sessions/${id}/messages`);
    document.getElementById('chat-title').textContent = activeSession.name || activeSession.preview || 'New Session';
    updateProcessingUI(activeSession.isProcessing);
    renderMessages(activeSession.messages);
    // Mark as read
    try { await api('POST', `/api/sessions/${id}/command`, { type: 'markRead' }); } catch {}
    // Update local state
    const s = sessions.find(s => s.id === id);
    if (s) { s.hasUnread = false; renderSessions(); }
  } catch (e) {
    document.getElementById('chat-title').textContent = 'Error';
    document.getElementById('messages').innerHTML = `<div class="msg msg-error">${esc(e.message)}</div>`;
  }
}

function renderMessages(messages) {
  const container = document.getElementById('messages');
  container.innerHTML = '';
  for (const msg of messages) {
    if (msg.role === 'user') {
      container.appendChild(createUserMsg(msg));
    } else if (msg.role === 'assistant') {
      container.appendChild(createAssistantMsg(msg));
    }
  }
  scrollToBottom();
}

function createUserMsg(msg) {
  const div = document.createElement('div');
  div.className = 'msg msg-user';
  div.textContent = typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content);
  return div;
}

function createAssistantMsg(msg) {
  const div = document.createElement('div');
  div.className = 'msg msg-assistant';
  const content = typeof msg.content === 'string' ? msg.content : '';
  div.innerHTML = renderMarkdown(content);

  // Render tool uses if present in content blocks
  if (Array.isArray(msg.content)) {
    for (const block of msg.content) {
      if (block.type === 'tool_use') {
        div.appendChild(createToolCallEl(block.id, block.name, block.input));
      } else if (block.type === 'tool_result') {
        // Find matching tool call and add result
        const existing = div.querySelector(`[data-tool-id="${block.tool_use_id}"]`);
        if (existing) {
          addToolResult(existing, typeof block.content === 'string' ? block.content : JSON.stringify(block.content));
        }
      } else if (block.type === 'text' && block.text) {
        const p = document.createElement('div');
        p.innerHTML = renderMarkdown(block.text);
        div.appendChild(p);
      }
    }
  }
  return div;
}

// ========== Streaming ==========
function getOrCreateStreamingMsg() {
  let el = document.getElementById('streaming-msg');
  if (!el) {
    el = document.createElement('div');
    el.id = 'streaming-msg';
    el.className = 'msg msg-assistant';
    document.getElementById('messages').appendChild(el);
  }
  return el;
}

function updateStreamingMsg() {
  const el = getOrCreateStreamingMsg();
  el.innerHTML = renderMarkdown(streamingText) + '<span class="streaming-cursor"></span>';
  scrollToBottom();
}

function finalizeStreamingMsg(text) {
  const el = document.getElementById('streaming-msg');
  if (el) {
    el.removeAttribute('id');
    el.innerHTML = renderMarkdown(text || streamingText);
  }
  streamingText = '';
  streamingTurnId = null;
}

// ========== Tool Calls ==========
function createToolCallEl(toolUseId, name, input, intent, displayName) {
  const div = document.createElement('div');
  div.className = 'tool-call';
  div.dataset.toolId = toolUseId;
  const displayLabel = displayName || name;
  const intentLabel = intent ? ` ‚Äî ${esc(intent)}` : '';
  div.innerHTML = `
    <div class="tool-header" onclick="toggleTool(this)">
      <span class="arrow">‚ñ∂</span>
      <span class="tool-name">${esc(displayLabel)}</span>
      <span class="tool-intent">${intentLabel}</span>
      <span class="tool-spinner" data-spinner></span>
    </div>
    <div class="tool-body">
      <pre>${esc(typeof input === 'string' ? input : JSON.stringify(input, null, 2))}</pre>
      <div class="tool-result"></div>
    </div>`;
  return div;
}

function addToolResult(toolEl, result, isError) {
  const spinner = toolEl.querySelector('[data-spinner]');
  if (spinner) spinner.remove();
  const resultDiv = toolEl.querySelector('.tool-result');
  resultDiv.innerHTML = `<div class="tool-result-label">${isError ? '‚ùå Error' : '‚úì Result'}</div><pre style="max-height: 200px;">${esc(truncate(result, 2000))}</pre>`;
}

function toggleTool(header) {
  const arrow = header.querySelector('.arrow');
  const body = header.nextElementSibling;
  arrow.classList.toggle('open');
  body.classList.toggle('open');
}

// ========== Permission Requests ==========
function showPermissionRequest(sessionId, request) {
  if (sessionId !== activeSessionId) return;
  const container = document.getElementById('messages');
  const div = document.createElement('div');
  div.className = 'permission-banner';
  div.id = `perm-${request.id}`;
  const tool = request.toolName || 'Unknown tool';
  const detail = request.input?.command || request.input?.description || JSON.stringify(request.input, null, 2);
  div.innerHTML = `
    <div class="perm-title">‚ö† Permission Required ‚Äî ${esc(tool)}</div>
    <div class="perm-detail">${esc(detail)}</div>
    <div class="perm-actions">
      <button class="btn-success" onclick="respondPermission('${request.id}', true, false)">Allow</button>
      <button class="btn-secondary" onclick="respondPermission('${request.id}', true, true)">Always Allow</button>
      <button class="btn-danger" onclick="respondPermission('${request.id}', false, false)">Deny</button>
    </div>`;
  container.appendChild(div);
  scrollToBottom();
}

async function respondPermission(requestId, allowed, alwaysAllow) {
  if (!activeSessionId) return;
  const el = document.getElementById(`perm-${requestId}`);
  try {
    await api('POST', `/api/sessions/${activeSessionId}/permission`, { requestId, allowed, alwaysAllow });
    if (el) {
      el.innerHTML = `<div style="font-size: 12px; color: var(--text-secondary);">${allowed ? '‚úì Allowed' : '‚úó Denied'}</div>`;
    }
  } catch (e) { console.error('Failed to respond to permission:', e); }
}

// ========== Credential Requests ==========
function showCredentialRequest(sessionId, request) {
  if (sessionId !== activeSessionId) return;
  const container = document.getElementById('messages');
  const div = document.createElement('div');
  div.className = 'credential-banner';
  div.id = `cred-${request.id}`;
  div.innerHTML = `
    <div class="cred-title">üîë Credential Required</div>
    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">${esc(request.description || 'Please enter your credentials')}</p>
    <div class="cred-field">
      <label>Value</label>
      <input type="password" id="cred-input-${request.id}" placeholder="Enter credential...">
    </div>
    <div class="cred-actions">
      <button class="btn-success" onclick="respondCredential('${request.id}')">Submit</button>
      <button class="btn-secondary" onclick="cancelCredential('${request.id}')">Cancel</button>
    </div>`;
  container.appendChild(div);
  scrollToBottom();
}

async function respondCredential(requestId) {
  if (!activeSessionId) return;
  const input = document.getElementById(`cred-input-${requestId}`);
  const value = input?.value || '';
  const el = document.getElementById(`cred-${requestId}`);
  try {
    await api('POST', `/api/sessions/${activeSessionId}/credential`, {
      requestId,
      response: { type: 'credential', value, cancelled: false }
    });
    if (el) el.innerHTML = '<div style="font-size: 12px; color: var(--text-secondary);">‚úì Credential submitted</div>';
  } catch (e) { console.error('Failed to submit credential:', e); }
}

async function cancelCredential(requestId) {
  if (!activeSessionId) return;
  const el = document.getElementById(`cred-${requestId}`);
  try {
    await api('POST', `/api/sessions/${activeSessionId}/credential`, {
      requestId,
      response: { type: 'credential', cancelled: true }
    });
    if (el) el.innerHTML = '<div style="font-size: 12px; color: var(--text-secondary);">‚úó Cancelled</div>';
  } catch (e) { console.error('Failed to cancel credential:', e); }
}

// ========== Send / Cancel ==========
async function sendMessage() {
  const input = document.getElementById('msg-input');
  const text = input.value.trim();
  if (!text || !activeSessionId) return;
  input.value = '';
  autoGrow(input);

  // Optimistic user message
  const msgEl = document.createElement('div');
  msgEl.className = 'msg msg-user';
  msgEl.textContent = text;
  document.getElementById('messages').appendChild(msgEl);
  scrollToBottom();
  updateProcessingUI(true);

  try {
    await api('POST', `/api/sessions/${activeSessionId}/messages`, { message: text });
  } catch (e) {
    const errEl = document.createElement('div');
    errEl.className = 'msg msg-error';
    errEl.textContent = `Failed to send: ${e.message}`;
    document.getElementById('messages').appendChild(errEl);
    updateProcessingUI(false);
  }
}

async function cancelProcessing() {
  if (!activeSessionId) return;
  try { await api('POST', `/api/sessions/${activeSessionId}/cancel`); } catch (e) { console.error('Cancel failed:', e); }
}

function updateProcessingUI(processing) {
  document.getElementById('stop-btn').classList.toggle('visible', processing);
  document.getElementById('chat-status').textContent = processing ? 'Processing...' : '';
  // Update local session state
  const s = sessions.find(s => s.id === activeSessionId);
  if (s) s.isProcessing = processing;
}

// ========== WebSocket Event Handler ==========
function handleEvent(event) {
  const sid = event.sessionId;

  switch (event.type) {
    case 'text_delta':
      if (sid === activeSessionId) {
        streamingText += event.delta;
        streamingTurnId = event.turnId;
        updateStreamingMsg();
      }
      break;

    case 'text_complete':
      if (sid === activeSessionId) {
        finalizeStreamingMsg(event.text);
        scrollToBottom();
      }
      break;

    case 'tool_start':
      if (sid === activeSessionId) {
        // Finalize any streaming text before tool call
        if (streamingText) finalizeStreamingMsg();
        const el = createToolCallEl(event.toolUseId, event.toolName, event.toolInput, event.toolIntent, event.toolDisplayName);
        document.getElementById('messages').appendChild(el);
        toolCalls.set(event.toolUseId, { name: event.toolName, input: event.toolInput });
        scrollToBottom();
      }
      break;

    case 'tool_result':
      if (sid === activeSessionId) {
        const toolEl = document.querySelector(`[data-tool-id="${event.toolUseId}"]`);
        if (toolEl) addToolResult(toolEl, event.result, event.isError);
        scrollToBottom();
      }
      break;

    case 'error':
      if (sid === activeSessionId) {
        if (streamingText) finalizeStreamingMsg();
        const errEl = document.createElement('div');
        errEl.className = 'msg msg-error';
        errEl.textContent = event.error;
        document.getElementById('messages').appendChild(errEl);
        scrollToBottom();
      }
      break;

    case 'typed_error':
      if (sid === activeSessionId) {
        if (streamingText) finalizeStreamingMsg();
        const errEl = document.createElement('div');
        errEl.className = 'msg msg-error';
        errEl.textContent = event.error?.message || JSON.stringify(event.error);
        document.getElementById('messages').appendChild(errEl);
        scrollToBottom();
      }
      break;

    case 'complete':
      if (sid === activeSessionId) {
        if (streamingText) finalizeStreamingMsg();
        updateProcessingUI(false);
        if (event.tokenUsage) {
          document.getElementById('chat-status').textContent =
            `Tokens: ${event.tokenUsage.inputTokens?.toLocaleString() || '?'}in / ${event.tokenUsage.outputTokens?.toLocaleString() || '?'}out` +
            (event.tokenUsage.costUsd ? ` ¬∑ $${event.tokenUsage.costUsd.toFixed(4)}` : '');
        }
      }
      // Update sidebar state
      { const s = sessions.find(s => s.id === sid);
        if (s) {
          s.isProcessing = false;
          if (sid !== activeSessionId) s.hasUnread = event.hasUnread ?? true;
          renderSessions();
        }
      }
      break;

    case 'interrupted':
      if (sid === activeSessionId) {
        if (streamingText) finalizeStreamingMsg();
        updateProcessingUI(false);
        const intEl = document.createElement('div');
        intEl.className = 'msg msg-status';
        intEl.textContent = '‚Äî Interrupted ‚Äî';
        document.getElementById('messages').appendChild(intEl);
      }
      break;

    case 'status':
      if (sid === activeSessionId) {
        document.getElementById('chat-status').textContent = event.message;
      }
      break;

    case 'info':
      if (sid === activeSessionId) {
        const infoEl = document.createElement('div');
        infoEl.className = 'msg msg-status';
        infoEl.textContent = event.message;
        document.getElementById('messages').appendChild(infoEl);
        scrollToBottom();
      }
      break;

    case 'permission_request':
      showPermissionRequest(sid, event.request);
      break;

    case 'credential_request':
      showCredentialRequest(sid, event.request);
      break;

    case 'title_generated':
      { const s = sessions.find(s => s.id === sid);
        if (s) { s.name = event.title; renderSessions(); }
        if (sid === activeSessionId) document.getElementById('chat-title').textContent = event.title;
      }
      break;

    case 'name_changed':
      { const s = sessions.find(s => s.id === sid);
        if (s) { s.name = event.name; renderSessions(); }
        if (sid === activeSessionId && event.name) document.getElementById('chat-title').textContent = event.name;
      }
      break;

    case 'user_message':
      { const s = sessions.find(s => s.id === sid);
        if (s) { s.lastMessageAt = Date.now(); s.isProcessing = true; }
        renderSessions();
        if (sid === activeSessionId) updateProcessingUI(true);
      }
      break;

    case 'session_deleted':
      sessions = sessions.filter(s => s.id !== sid);
      renderSessions();
      if (sid === activeSessionId) {
        activeSessionId = null;
        activeSession = null;
        document.getElementById('chat-title').textContent = 'Select a session';
        document.getElementById('messages').innerHTML = '<div id="empty-state"><p>Session deleted</p></div>';
      }
      break;

    case 'todo_state_changed':
      { const s = sessions.find(s => s.id === sid);
        if (s) { s.todoState = event.todoState; renderSessions(); }
      }
      break;

    case 'session_flagged':
      { const s = sessions.find(s => s.id === sid);
        if (s) { s.isFlagged = true; renderSessions(); }
      }
      break;

    case 'session_unflagged':
      { const s = sessions.find(s => s.id === sid);
        if (s) { s.isFlagged = false; renderSessions(); }
      }
      break;

    case 'permission_mode_changed':
      if (sid === activeSessionId && activeSession) {
        activeSession.permissionMode = event.permissionMode;
      }
      break;

    case 'working_directory_changed':
      if (sid === activeSessionId && activeSession) {
        activeSession.workingDirectory = event.workingDirectory;
      }
      break;

    case 'plan_submitted':
      if (sid === activeSessionId && event.message) {
        const planEl = document.createElement('div');
        planEl.className = 'msg msg-plan';
        const content = typeof event.message.content === 'string' ? event.message.content : '';
        planEl.innerHTML = '<strong style="color: var(--accent);">üìã Plan</strong><br>' + renderMarkdown(content);
        document.getElementById('messages').appendChild(planEl);
        scrollToBottom();
      }
      break;

    case 'task_backgrounded':
    case 'shell_backgrounded':
      if (sid === activeSessionId) {
        const bgEl = document.createElement('div');
        bgEl.className = 'msg msg-status';
        bgEl.textContent = `‚è≥ Background ${event.type === 'task_backgrounded' ? 'task' : 'shell'}: ${event.intent || event.command || event.taskId || event.shellId}`;
        document.getElementById('messages').appendChild(bgEl);
        scrollToBottom();
      }
      break;

    case 'usage_update':
      if (sid === activeSessionId && event.tokenUsage) {
        document.getElementById('chat-status').textContent = `Processing... (${event.tokenUsage.inputTokens?.toLocaleString() || '?'} tokens)`;
      }
      break;

    case 'labels_changed':
      { const s = sessions.find(s => s.id === sid);
        if (s) { s.labels = event.labels; }
      }
      break;

    case 'sources_changed':
      if (sid === activeSessionId && activeSession) {
        activeSession.enabledSourceSlugs = event.enabledSourceSlugs;
      }
      break;

    case 'async_operation':
    case 'title_regenerating':
    case 'task_progress':
    case 'auth_request':
    case 'auth_completed':
    case 'source_activated':
    case 'session_model_changed':
      // Acknowledged but no UI update needed for MVP
      break;

    case 'pong':
    case 'connected':
      break;

    default:
      console.log('[ws] unhandled event:', event.type, event);
  }
}

// ========== Helpers ==========
function esc(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function truncate(str, max) {
  if (!str || str.length <= max) return str;
  return str.slice(0, max) + '... (truncated)';
}

function relTime(ts) {
  if (!ts) return '';
  const diff = (Date.now() - ts) / 1000;
  if (diff < 60) return 'now';
  if (diff < 3600) return `${Math.floor(diff / 60)}m`;
  if (diff < 86400) return `${Math.floor(diff / 3600)}h`;
  if (diff < 604800) return `${Math.floor(diff / 86400)}d`;
  return new Date(ts).toLocaleDateString();
}

function renderMarkdown(text) {
  if (!text) return '';
  // Simple markdown: code blocks, inline code, bold, italic, links, headings, lists
  let html = esc(text);
  // Code blocks
  html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
  // Inline code
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
  // Bold
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  // Italic
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
  // Headings
  html = html.replace(/^### (.+)$/gm, '<h4>$1</h4>');
  html = html.replace(/^## (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^# (.+)$/gm, '<h2>$1</h2>');
  // Lists
  html = html.replace(/^- (.+)$/gm, '‚Ä¢ $1<br>');
  html = html.replace(/^\d+\. (.+)$/gm, '$&<br>');
  // Line breaks
  html = html.replace(/\n/g, '<br>');
  return html;
}

function scrollToBottom() {
  const el = document.getElementById('messages');
  requestAnimationFrame(() => { el.scrollTop = el.scrollHeight; });
}

function autoGrow(textarea) {
  textarea.style.height = 'auto';
  textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
}

function handleInputKey(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
}

function toggleSidebar() {
  document.getElementById('sidebar').classList.toggle('open');
}

// ========== Auto-connect ==========
window.addEventListener('DOMContentLoaded', () => {
  const savedUrl = localStorage.getItem('wb_url');
  const savedToken = localStorage.getItem('wb_token');
  if (savedUrl) document.getElementById('input-url').value = savedUrl;
  if (savedToken) document.getElementById('input-token').value = savedToken;

  // Pre-fill URL from current location if accessing the embedded server
  if (!savedUrl && location.port) {
    document.getElementById('input-url').value = `${location.protocol}//${location.host}`;
  }
});

// Keepalive ping
setInterval(() => { if (ws?.readyState === 1) ws.send(JSON.stringify({ type: 'ping' })); }, 30000);
</script>
</body>
</html>
